
# 一、基本流程
```angular2html
fn verify(
    key: H256,
    v: Word,
    leaves_bitmap: H256,
    siblings: Vec<MergeValue>,
    root: H256
) -> bool {
    // 定义初始路径
    let mut current_path = key;
    let mut n = 0;
    // 初始化节点的MergeValue
    let mut current_v = MergeValue::ShortCut {
        key: key,
        value: keccak256(v.0.as_bytes()).into(),
        height: 0,
    };

    // 定义左右节点的MergeValue
    let mut left: MergeValue = MergeValue::zero();
    let mut right: MergeValue = MergeValue::zero();

    // 循环遍历0到255（包括255）
    for i in 0..=u8::MAX {
        // 根据当前节点的路径得到父节点的路径
        let parent_path = current_path.parent_path(i);

        // 如果有兄弟节点（两个节点都是非零)
        if leaves_bitmap.get_bit(i) {
            if current_path.is_right(i) {
                left = siblings[n].clone();
                right = current_v.clone();
            } else {
                left = current_v.clone();
                right = siblings[n].clone();
            }

            n += 1;
        }
        // 如果没有兄弟节点（遇到零的兄弟节点）
        else {
            if current_path.is_right(i) {
                left = MergeValue::zero();
                right = current_v.clone();
            } else {
                left = current_v.clone();
                right = MergeValue::zero();
            }
        }

        // 计算父节点的MergeValue  （高度， 父节点路径， 左节点， 右节点）
        current_v = merge::<Keccak256Hasher>(i, &parent_path, &left, &right);

        // 把父节点设置为当前节点
        current_path = parent_path;
    }

    // 循环结束 获得新的root
    let new_root = current_v.hash::<Keccak256Hasher>();
    new_root == root

}
```

# 二、涉及到的结构体
1. 叶子
```angular2html

/// 表达节点的数据结构 (一般普通默克尔用hash值; 这里用枚举)
pub enum MergeValue {
    // 说明该节点有两个非零的子节点
    Value(H256),
    // 说明该节点有一个非零子节点
    MergeWithZero {
        base_node: H256,
        zero_bits: H256,
        zero_count: u8,
    },
    // 说明该节点没有任何子节点（仅仅用于初始化）
    #[cfg(feature = "trie")]
    ShortCut {
        key: H256,
        value: H256,
        height: u8,
    },
}
```
2. 32个字节的u8数组
```angular2html
pub struct H256([u8; 32]);
```
> 用于表达节点路径或者hash256算法计算出来的值

# 三、涉及到的方法
1. 跟`H256([u8; 32])`操作相关 [https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/h256.rs#L10](https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/h256.rs#L10)
> 比较简单
2. 父节点的MergeValue生成 [https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs#L118](https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs#L118)
    * 代码 `fn merge(
      height: u8, // 节点高度
      node_key: &H256, // 父节点路径
      lhs: &MergeValue, // 左节点MergeValue
      rhs: &MergeValue, // 右节点MergeValue
      ) -> MergeValue`
    * 逻辑
        * 如果都是零节点， 返回零
        * 如果左节点是零， 那么执行函数 `merge_with_zero(height, node_key, rhs, true)`
        * 如果右节点是0， 那么执行函数 `merge_with_zero(height, node_key, lhs, false)`
        * 如果都是非零，那么执行 `keccak256(1, height, node_key, rhs)`
3. 有非零兄弟节点时，父节点MergeValue的运算 [https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs#L142](https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs#L142)
    * 代码 `merge_with_zero(
      height: u8,
      node_key: &H256,
      value: &MergeValue,
      set_bit: bool,
      ) -> MergeValue`
    * 逻辑：
        逻辑略， 最重要的是如果是第一次遇到非零节点，会额外执行函数`hash_base_node::<H>(height, node_key, v)`获得父节点的`base_node`字段值
4. 第一次遇到非零节点, 计算父节点的 `base_node`字段值 [https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs#L103]
    * 代码： `hash_base_node(
      base_height: u8,
      base_key: &H256,
      base_value: &H256,
      )`
    * 逻辑：
        `keccak256(base_height, base_key, base_value)

5. 根据根节点的MergeValue获取root [https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs#L55](https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs#L55)
    * 代码 `fn hash<H: Hasher + Default>(&self) -> H256`
    * 逻辑：
      * 略
      
# PS
涉及到的方法都在以下的两个文件中
1. [32长读u8数组相关运算](https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/h256.rs)
2. [父节点的MergeValue计算](https://github.com/nervosnetwork/sparse-merkle-tree/blob/master/src/merge.rs)

#  验证通过的数据范本

```asm
path: H256([100, 54, 188, 16, 201, 101, 168, 46, 60, 237, 139, 56, 110, 5, 184, 76, 138, 61, 113, 147, 112, 26, 64, 25, 164, 98, 55, 171, 213, 211, 26, 250])
value: ProfitStateData { token: 0x0000000000000000000000000000000000000021, token_chain_id: 101, balance: 100, debt: 80 }
value: hash: H256([145, 111, 34, 84, 207, 60, 166, 161, 85, 242, 100, 54, 145, 145, 68, 144, 253, 49, 216, 145, 240, 106, 205, 238, 70, 118, 203, 14, 43, 209, 227, 168])
bitmap: H256([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32])
siblings: [MergeWithZero { base_node: H256([57, 174, 184, 174, 151, 165, 212, 16, 193, 125, 144, 62, 169, 40, 243, 226, 18, 10, 63, 230, 138, 19, 196, 120, 12, 4, 147, 254, 127, 178, 21, 183]), zero_bits: H256([49, 54, 78, 75, 206, 124, 52, 137, 67, 252, 122, 46, 105, 253, 77, 145, 44, 50, 88, 26, 103, 47, 101, 29, 191, 4, 245, 109, 91, 2, 142, 7]), zero_count: 253 }]
root: H256([11, 59, 226, 241, 160, 235, 198, 63, 190, 158, 1, 154, 228, 111, 71, 245, 178, 124, 94, 107, 171, 219, 193, 158, 60, 177, 176, 181, 207, 28, 36, 49])
----------hex------------
path hex: "6436bc10c965a82e3ced8b386e05b84c8a3d7193701a4019a46237abd5d31afa"
value hash hex: "916f2254cf3ca6a155f2643691914490fd31d891f06acdee4676cb0e2bd1e3a8"
bitmap hex: "0000000000000000000000000000000000000000000000000000000000000020"
sibling 0 hex: base_node: 39aeb8ae97a5d410c17d903ea928f3e2120a3fe68a13c4780c0493fe7fb215b7, zero_bits: 31364e4bce7c348943fc7a2e69fd4d912c32581a672f651dbf04f56d5b028e07, zero_count: 253
root hex: "0b3be2f1a0ebc63fbe9e019ae46f47f5b27c5e6babdbc19e3cb1b0b5cf1c2431"
--------------------------------------------------------------------------------------------------------------------
```